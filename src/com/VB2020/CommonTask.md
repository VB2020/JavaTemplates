Общая задача для всех попрождающих шаблонов:
отделить процесс создания обьектов
от логики основной программы.
--------------------------------------------------
Попрождающие шаблоны важны когда
система больше зависит от композиции обьектов
чем от наследования классов.
--------------------------------------------------
На основе композиции мы создаем
набор более сложных обьектов.
--------------------------------------------------
Мы не напрямую создаем обьект,
а создаем некий конструктор,
на основе которого создаем нужный нам обьект
--------------------------------------------------
Эти шаблоны помогают скрыть взаимодействие классов
между собой.

//////////////////////////////////////////
Но есть еще и структурные шаблоны.
Их цель - создание более крупной структуры
из классов и обьектов.

Используют наследование
для составления композиций
из интерфейсов и реализаций.

---на уровне классов-------------------------
Множественное наследование
помогает нам обьединить 
много классов в один, у которого есть
все свойства своих родителей.

Хотим создать совместную работу
независимых меду собой библиотек.

---на уровне обьектов------------------------
компануют обьекты для получения
новых функциональностей.

можем изменить композицию обьектов
во время выполнения программы.

А это недопустимо при использовании
статической композиции классов.

-------------------------------------
В тех задачах, в которых применяем
например адаптер и мост,
то здесь недопустимо применение 
компоновщика, декоратора и прокси.

//////////////////////////////////////////
// ------------------поведенческие шаблоны

хорошее взаимодействие друг с другом.

например там где используем компоновщик,
то вместе с ним еще и посетитель можно
для выполнения операций над компонентами.

А у компонент есть доступ
к общим свойствам через суперклассы.
